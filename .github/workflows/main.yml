name: Deploy Service

on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: "Branch to fetch environment files from"
        required: true
        default: "unified-env-lts"
      env_file:
        description: "Environment file to use (set manually after fetching the list)"
        required: true
      cluster_name:
        description: "EKS cluster name to log in to"
        required: true
      region:
        description: "AWS region of the EKS cluster"
        required: true
        default: "ap-south-1"
      docker_image:
        description: "Docker image to deploy (e.g., egov-mdms-service:core-2.9-lts)"
        required: true
      deploy_secrets:
        description: "Set to true to deploy secrets"
        required: true
        type: boolean

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

jobs:
  deploy-docker-image:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the branch
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.branch_name }}
        
      - name: Install SOPS (if not installed)
        run: |
          echo "Checking if SOPS is installed..."
          if ! command -v sops &> /dev/null; then
            echo "SOPS not found. Installing..."
            SOPS_LATEST_VERSION=$(curl -s "https://api.github.com/repos/getsops/sops/releases/latest" | grep -Po '"tag_name": "v\K[0-9.]+')
            curl -Lo sops.deb "https://github.com/getsops/sops/releases/download/v${SOPS_LATEST_VERSION}/sops_${SOPS_LATEST_VERSION}_amd64.deb"
            sudo apt --fix-broken install ./sops.deb
            sudo apt-get update
            sudo apt-get install sops
          else
            echo "SOPS is already installed, skipping installation."
          fi

      - name: Install yq
        run: |
          echo "Installing yq..."
          sudo wget -q https://github.com/mikefarah/yq/releases/download/v4.27.5/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Verify installations
        run: |
          sops --version
          yq --version


      Step 3: Set up SOPS age key
      - name: Set Up SOPS Key
        run: |
          echo "${{ secrets.SOPS_AGE_KEY }}" > ./sops-age-key.txt
          export SOPS_AGE_KEY_FILE=./sops-age-key.txt
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}

      - name: Decrypt Secrets File
        id: fetch_secrets
        run: |
          # Define the path to secrets file
          SECRETS_FILE_PATH="./deploy-as-code/helm/environments/${{ github.event.inputs.env_file }}-secrets.yaml"

          # Check if the secrets file exists
          if [ ! -f "$SECRETS_FILE_PATH" ]; then
            echo "Error: Secrets file not found at $SECRETS_FILE_PATH"
            exit 1
          fi
          
          # Decrypt only the secrets file
          echo "Decrypting secrets file: $SECRETS_FILE_PATH"
          sops -d "$SECRETS_FILE_PATH" | kubectl apply -f -

      # Step 2: Fetch and Source the Env File
      - name: Fetch and Source Env File
        id: fetch_env
        run: |
          ENV_FILE_PATH="./deploy-as-code/helm/environments/${{ github.event.inputs.env_file }}"
          
          if [ ! -f "$ENV_FILE_PATH" ]; then
            echo "Error: The specified environment file $ENV_FILE_PATH does not exist"
            exit 1
          fi
          
          echo "Using environment file: $ENV_FILE_PATH"
          
          # Extract domain name under the global section using yq
          DOMAIN_NAME=$(yq e '.global.domain' $ENV_FILE_PATH)
          
          if [ -z "$DOMAIN_NAME" ]; then
            echo "Error: Domain name not found in the environment file"
            exit 1
          fi
          
          echo "Domain Name: $DOMAIN_NAME"
          echo "DOMAIN_NAME=$DOMAIN_NAME" >> $GITHUB_ENV

      # Step 3: Install or Update AWS CLI
      - name: Install or Update AWS CLI
        run: |
          if aws --version &>/dev/null; then
            echo "AWS CLI is already installed. Skipping installation."
          else
            echo "AWS CLI not found. Installing..."
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
          fi
          aws --version
      # Step 4: Configure AWS CLI
      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
          aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
          aws configure set default.region ${{ github.event.inputs.region }}
      # Step 5: Generate kubeconfig for EKS
      - name: Generate kubeconfig for EKS
        run: |
          echo "Generating kubeconfig for EKS cluster: ${{ github.event.inputs.cluster_name }}"
          aws eks update-kubeconfig --name ${{ github.event.inputs.cluster_name }} --region ${{ github.event.inputs.region }}
          kubectl config view
      # Step 6: Verify Cluster Login
      - name: Verify Cluster Login
        run: |
          echo "Attempting to log in to Kubernetes cluster"
          kubectl get nodes

      # # Step 6: Deploy Secrets and Configs
      # - name: Deploy Secrets and Configs
      #   if: ${{ github.event.inputs.deploy_secrets == 'true' }}
      #   run: |
      #     echo "Deploying secrets and cluster configurations..."
      #     CONFIGS_DIR="./deploy-as-code/helm/charts/cluster-configs"
      #     SECRETS_FILE="${CONFIGS_DIR}/secrets/${{ github.event.inputs.env_file }}-secrets.yaml"

      #     if [ ! -f "$SECRETS_FILE" ]; then
      #       echo "Error: Secrets file $SECRETS_FILE does not exist"
      #       exit 1
      #     fi

      #     echo "Applying secrets..."
      #     kubectl apply -f "$SECRETS_FILE"

      #     echo "Applying cluster configuration files..."
      #     for resource in secrets services ingress configmaps; do
      #       RESOURCE_DIR="$CONFIGS_DIR/$resource"
      #       if [ -d "$RESOURCE_DIR" ]; then
      #         kubectl apply -f "$RESOURCE_DIR" --recursive
      #         echo "Applied configurations from $RESOURCE_DIR"
      #       else
      #         echo "No configurations found for $resource"
      #       fi
      #     done

      # Step 8: Deploy Service
      - name: Deploy Service
        run: |
          # Authenticate with Docker registry
          echo "Logging into Docker registry..."
          echo "${{ secrets.DOCKER_ACCESS_TOKEN }}" | docker login --username "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          
          # Input: Docker image name
          DOCKER_IMAGE=$DOCKER_IMAGE
          
          # Extract service name from the Docker image
          SERVICE_NAME=$(echo "$DOCKER_IMAGE" | cut -d':' -f1)
          
          # Define the DB Docker image by appending '-db' to the service name
          DB_IMAGE="${SERVICE_NAME}-db:${DOCKER_IMAGE##*:}"
          
          echo "Application Image: $DOCKER_IMAGE"
          echo "Database Image: $DB_IMAGE"
          # Check if the DB image exists in the Docker repository
          echo "Checking if the database image exists..."
          if docker pull harish7303/"$DB_IMAGE" &>/dev/null; then
            echo "Database image found: $DB_IMAGE"
            DB_EXISTS=true
          else
            echo "Database image not found. Only deploying the application container."
            DB_EXISTS=false
          fi
          
          # Define the base charts directory
          CHARTS_DIR="./deploy-as-code/helm/charts"
          
          # Search for the chart directory containing the service name
          CHART_DIR=$(find "$CHARTS_DIR" -type d -name "$SERVICE_NAME" -exec test -f {}/Chart.yaml \; -print -quit)
          
          if [ -z "$CHART_DIR" ]; then
              echo "Error: No Helm chart found for service '$SERVICE_NAME' in $CHARTS_DIR."
              exit 1
          fi
          
          echo "Found Helm chart for '$SERVICE_NAME' at: $CHART_DIR"
          
          # Step 1: Build Helm chart dependencies (resolve local charts)
          echo "Building Helm chart dependencies..."
          helm dependency build "$CHART_DIR"
          
          # Step 2: Detect namespace from Helm chart (if it's not defined, default to 'egov')
          NAMESPACE=$(yq e '.namespace // "egov"' "$CHART_DIR/values.yaml")
          echo "Using namespace: $NAMESPACE"
          
          # Step 3: Deploy using Helm
          echo "Deploying service using Helm..."
          
          if [ "$DB_EXISTS" = true ]; then
            echo "Deploying application and database containers..."
            helm upgrade --install "$SERVICE_NAME" "$CHART_DIR" \
              --namespace "$NAMESPACE" \
              -f "$CHART_DIR/values.yaml" \
              --set image.tag="${DOCKER_IMAGE##*:}" \
              --set initContainers.dbMigration.image.tag="${DB_IMAGE##*:}" \
              --set global.domain="$DOMAIN_NAME" \
              --set db.image.repository="$SERVICE_NAME-db"  # Explicitly set the db image repository
          else
            echo "Deploying only the application container..."
            helm upgrade --install "$SERVICE_NAME" "$CHART_DIR" \
              --namespace "$NAMESPACE" \
              -f "$CHART_DIR/values.yaml" \
              --set image.tag="${DOCKER_IMAGE##*:}" \
              --set global.domain="$DOMAIN_NAME"
          fi
        shell: /usr/bin/bash -e {0}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          DOCKER_IMAGE: ${{ github.event.inputs.docker_image }}

      # - name: Deploy Service
      #   run: |
      #     # Input: Docker image name
      #     DOCKER_IMAGE=$DOCKER_IMAGE
          
      #     # Extract service name from the Docker image
      #     SERVICE_NAME=$(echo "$DOCKER_IMAGE" | cut -d':' -f1)
          
      #     # Define the base charts directory
      #     CHARTS_DIR="./deploy-as-code/helm/charts"
          
      #     # Search for the chart directory containing the service name
      #     CHART_DIR=$(find "$CHARTS_DIR" -type d -name "$SERVICE_NAME" -exec test -f {}/Chart.yaml \; -print -quit)
          
      #     if [ -z "$CHART_DIR" ]; then
      #         echo "Error: No Helm chart found for service '$SERVICE_NAME' in $CHARTS_DIR."
      #         exit 1
      #     fi
          
      #     echo "Found Helm chart for '$SERVICE_NAME' at: $CHART_DIR"
          
      #     # Step 1: Build Helm chart dependencies (resolve local charts)
      #     echo "Building Helm chart dependencies..."
      #     helm dependency build "$CHART_DIR"
          
      #     # Step 2: Detect namespace from Helm chart (if it's not defined, default to 'egov')
      #     NAMESPACE=$(yq e '.namespace // "egov"' "$CHART_DIR/values.yaml")
          
      #     echo "Using namespace: $NAMESPACE"
          
      #     # Step 3: Deploy using Helm
      #     echo "Deploying service using Helm..."
      #     helm upgrade --install "$SERVICE_NAME" "$CHART_DIR" \
      #       --namespace "$NAMESPACE" \
      #       -f "$CHART_DIR/values.yaml" \
      #       --set image.tag="${DOCKER_IMAGE##*:}" \
      #       --set global.domain="$DOMAIN_NAME"  # Pass the DOMAIN_NAME to global.domain in Helm chart
      #   shell: /usr/bin/bash -e {0}
      #   env:
      #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     DOCKER_IMAGE: ${{ github.event.inputs.docker_image }}

      # Step 8: Configure Ingress Resource
      # - name: Configure Ingress Resource
      #   run: |
      #     echo "Configuring Ingress for service: $SERVICE_NAME"

      #     # Ensure SERVICE_NAME is set correctly
      #     if [ -z "$SERVICE_NAME" ]; then
      #       echo "Error: SERVICE_NAME is empty. Check the Docker image input."
      #       exit 1
      #     fi

      #     # Dynamically construct the path to the ingress YAML for the service
      #     if [ "$SERVICE_NAME" == "common" ]; then
      #       INGRESS_YAML_PATH="./deploy-as-code/helm/charts/common/templates/_ingress.yaml"
      #     else
      #       INGRESS_YAML_PATH="./deploy-as-code/helm/charts/common-services/$SERVICE_NAME/templates/ingress.yaml"
      #     fi

      #     # Check if the ingress YAML exists
      #     if [ ! -f "$INGRESS_YAML_PATH" ]; then
      #       echo "Error: Ingress YAML file for service '$SERVICE_NAME' does not exist at '$INGRESS_YAML_PATH'"
      #       exit 1
      #     fi

      #     # Apply the Ingress resource
      #     kubectl apply -f "$INGRESS_YAML_PATH" --namespace="$NAMESPACE"

      #     echo "Ingress resource applied successfully"

      # Step 9: Verify Deployment
      # - name: Verify Deployment
      #   run: |
      #     # Extract service name from Docker image
      #     SERVICE_NAME=$(echo "${{ github.event.inputs.docker_image }}" | cut -d':' -f1)
          
      #     # Define the base charts directory
      #     CHARTS_DIR="./deploy-as-code/helm/charts"
          
      #     # Search for the chart directory containing the service name
      #     CHART_DIR=$(find "$CHARTS_DIR" -type d -name "$SERVICE_NAME" -exec test -f {}/Chart.yaml \; -print -quit)
          
      #     if [ -z "$CHART_DIR" ]; then
      #         echo "Error: No Helm chart found for service '$SERVICE_NAME' in $CHARTS_DIR."
      #         exit 1
      #     fi
          
      #     # Detect namespace from Helm chart
      #     NAMESPACE=$(yq e '.namespace // "default"' "$CHART_DIR/values.yaml")
          
      #     echo "Verifying deployment for service: $SERVICE_NAME in namespace: $NAMESPACE"
          
      #     # Verify rollout status in the correct namespace
      #     kubectl rollout status deployment/$SERVICE_NAME --namespace="$NAMESPACE"