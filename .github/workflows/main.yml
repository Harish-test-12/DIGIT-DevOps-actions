name: Deploy Service

on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: "Branch to fetch environment files from"
        required: true
        default: "unified-env-lts"
      env_file:
        description: "Environment file to use (set manually after fetching the list)"
        required: true
      cluster_name:
        description: "EKS cluster name to log in to"
        required: true
      region:
        description: "AWS region of the EKS cluster"
        required: true
        default: "ap-south-1"
      docker_image:
        description: "Docker image to deploy (e.g., egov-mdms-service:core-2.9-lts)"
        required: true
      db_docker_image:
        description: "Database Docker image to deploy (e.g., egov-mdms-db:latest)"
        required: true

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

jobs:
  deploy-docker-image:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the branch
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.branch_name }}

      # Step 2: Fetch and Source the Env File
      - name: Fetch and Source Env File
        id: fetch_env
        run: |
          ENV_FILE_PATH="./deploy-as-code/helm/environments/${{ github.event.inputs.env_file }}"
          
          if [ ! -f "$ENV_FILE_PATH" ]; then
            echo "Error: The specified environment file $ENV_FILE_PATH does not exist"
            exit 1
          fi
          
          echo "Using environment file: $ENV_FILE_PATH"
          
          # Extract domain name under the global section using yq
          DOMAIN_NAME=$(yq e '.global.domain' $ENV_FILE_PATH)
          
          if [ -z "$DOMAIN_NAME" ]; then
            echo "Error: Domain name not found in the environment file"
            exit 1
          fi
          
          echo "Domain Name: $DOMAIN_NAME"
          
          # Export the variable for use later in the workflow
          echo "DOMAIN_NAME=$DOMAIN_NAME" >> $GITHUB_ENV

      # Step 3: Install or Update AWS CLI
      - name: Install or Update AWS CLI
        run: |
          if aws --version &>/dev/null; then
            echo "AWS CLI is already installed. Skipping installation."
          else
            echo "AWS CLI not found. Installing..."
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
          fi
          aws --version

      # Step 4: Configure AWS CLI
      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
          aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
          aws configure set default.region ${{ github.event.inputs.region }}

      # Step 5: Generate kubeconfig for EKS
      - name: Generate kubeconfig for EKS
        run: |
          echo "Generating kubeconfig for EKS cluster: ${{ github.event.inputs.cluster_name }}"
          aws eks update-kubeconfig --name ${{ github.event.inputs.cluster_name }} --region ${{ github.event.inputs.region }}
          kubectl config view

      # Step 6: Verify Cluster Login
      - name: Verify Cluster Login
        run: |
          echo "Attempting to log in to Kubernetes cluster"
          kubectl get nodes

      # Step 7: Deploy Application Service
      - name: Deploy Application Service
        run: |
          # Input: Docker image name for the app
          APP_DOCKER_IMAGE=${{ github.event.inputs.docker_image }}
          
          # Extract service name from the Docker image
          APP_SERVICE_NAME=$(echo "$APP_DOCKER_IMAGE" | cut -d':' -f1)
          
          # Define the base charts directory
          CHARTS_DIR="./deploy-as-code/helm/charts"
          
          # Search for the chart directory containing the service name
          CHART_DIR=$(find "$CHARTS_DIR" -type d -name "$APP_SERVICE_NAME" -exec test -f {}/Chart.yaml \; -print -quit)
          
          if [ -z "$CHART_DIR" ]; then
              echo "Error: No Helm chart found for app service '$APP_SERVICE_NAME' in $CHARTS_DIR."
              exit 1
          fi
          
          echo "Found Helm chart for '$APP_SERVICE_NAME' at: $CHART_DIR"
          
          # Step 1: Build Helm chart dependencies (resolve local charts)
          echo "Building Helm chart dependencies..."
          helm dependency build "$CHART_DIR"
          
          # Step 2: Detect namespace from Helm chart
          NAMESPACE=$(yq e '.namespace // "default"' "$CHART_DIR/values.yaml")
          
          echo "Using namespace: $NAMESPACE"
          
          # Step 3: Deploy using Helm
          echo "Deploying application service using Helm..."
          helm upgrade --install "$APP_SERVICE_NAME" "$CHART_DIR" \
            --namespace "$NAMESPACE" \
            -f "$CHART_DIR/values.yaml" \
            --set image.tag="${APP_DOCKER_IMAGE##*:}" \
            --set global.domain="$DOMAIN_NAME"  # Pass the DOMAIN_NAME to global.domain in Helm chart

      # Step 8: Deploy Database Service
      - name: Deploy Database Service
        run: |
          # Input: Docker image name for the database
          DB_DOCKER_IMAGE=${{ github.event.inputs.db_docker_image }}
          
          # Extract service name from the Docker image
          DB_SERVICE_NAME=$(echo "$DB_DOCKER_IMAGE" | cut -d':' -f1)
          
          # Define the base charts directory for database service
          CHARTS_DIR="./deploy-as-code/helm/charts"
          
          # Search for the chart directory containing the DB service name
          CHART_DIR=$(find "$CHARTS_DIR" -type d -name "$DB_SERVICE_NAME" -exec test -f {}/Chart.yaml \; -print -quit)
          
          if [ -z "$CHART_DIR" ]; then
              echo "Error: No Helm chart found for DB service '$DB_SERVICE_NAME' in $CHARTS_DIR."
              exit 1
          fi
          
          echo "Found Helm chart for DB service '$DB_SERVICE_NAME' at: $CHART_DIR"
          
          # Step 1: Build Helm chart dependencies (resolve local charts)
          echo "Building Helm chart dependencies for DB..."
          helm dependency build "$CHART_DIR"
          
          # Step 2: Detect namespace from Helm chart
          NAMESPACE=$(yq e '.namespace // "default"' "$CHART_DIR/values.yaml")
          
          echo "Using namespace for DB: $NAMESPACE"
          
          # Step 3: Deploy database using Helm
          echo "Deploying database service using Helm..."
          helm upgrade --install "$DB_SERVICE_NAME" "$CHART_DIR" \
            --namespace "$NAMESPACE" \
            -f "$CHART_DIR/values.yaml" \
            --set image.tag="${DB_DOCKER_IMAGE##*:}" \
            --set global.domain="$DOMAIN_NAME"  # Pass the DOMAIN_NAME to global.domain in Helm chart

      # Step 9: Verify Deployment
      - name: Verify Deployment
        run: |
          # Extract service name from Docker image for app
          APP_SERVICE_NAME=$(echo "${{ github.event.inputs.docker_image }}" | cut -d':' -f1)
          
          # Define the base charts directory
          CHARTS_DIR="./deploy-as-code/helm/charts"
          
          # Search for the chart directory containing the service name
          CHART_DIR=$(find "$CHARTS_DIR" -type d -name "$APP_SERVICE_NAME" -exec test -f {}/Chart.yaml \; -print -quit)
          
          if [ -z "$CHART_DIR" ]; then
              echo "Error: No Helm chart found for service '$APP_SERVICE_NAME' in $CHARTS_DIR."
              exit 1
          fi
          
          # Detect namespace from Helm chart
          NAMESPACE=$(yq e '.namespace // "default"' "$CHART_DIR/values.yaml")
          
          echo "Verifying deployment for service: $APP_SERVICE_NAME in namespace: $NAMESPACE"
          
          # Verify rollout status for app service
          kubectl rollout status deployment/$APP_SERVICE_NAME --namespace="$NAMESPACE"
          
          # Extract service name for DB deployment
          DB_SERVICE_NAME=$(echo "${{ github.event.inputs.db_docker_image }}" | cut -d':' -f1)
          
          # Verify rollout status for DB service
          kubectl rollout status deployment/$DB_SERVICE_NAME --namespace="$NAMESPACE"
